mod gf2p8;

pub use gf2p8::bit_matrix::BitMatrix;
pub use gf2p8::generic::Gf2p8;

pub mod generated {
    // Include the constants generated by build.rs
    include!(concat!(env!("OUT_DIR"), "/twiddle_factors_11d.rs"));
}

/// The Additive FFT Recursive Step
/// This divides the N shards into two N/2 square sub-problems.
pub fn fft_recursive(shards: &mut [&mut [u8]], twiddles: &[BitMatrix]) {
    let n = shards.len();
    if n <= 1 {
        return;
    }

    let half = n / 2;

    // 1. Split into Top and Bottom square submatrices
    let (top, bottom) = shards.split_at_mut(half);

    // 2. Recursive Step (Divide)
    fft_recursive(top, &twiddles[1..]);
    fft_recursive(bottom, &twiddles[1..]);

    // 3. Butterfly Combine (Conquer)
    // In an additive FFT, this stage interacts rows of the top block with the bottom block.
    let mat = twiddles[0];

    for i in 0..half {
        for j in 0..top[i].len() {
            let u = top[i][j];
            let v = bottom[i][j];

            // Standard Additive Butterfly:
            // u' = u + v
            // v' = v * Twiddle + u
            let u_new = u ^ v;
            let v_weighted = mat.apply(v);
            let v_new = v_weighted ^ u; // Note: using 'u' here preserves entropy

            top[i][j] = u_new;
            bottom[i][j] = v_new;
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_recursive_fft_4_shards() {
        // Data: 4 shards of 2 bytes each
        let mut s0 = [10, 20];
        let mut s1 = [30, 40];
        let mut s2 = [50, 60];
        let mut s3 = [70, 80];

        let mut shards: Vec<&mut [u8]> = vec![&mut s0, &mut s1, &mut s2, &mut s3];

        fft_recursive(&mut shards, &generated::TWIDDLE_FACTORS_11D);

        println!("s0: {:?}, s1: {:?}, s2: {:?}, s3: {:?}", s0, s1, s2, s3);

        // Verify that all shards were modified
        assert_ne!(s0, [10, 20], "Shard 0 was not modified");
        assert_ne!(s1, [30, 40], "Shard 1 was not modified");
        assert_ne!(s2, [50, 60], "Shard 2 was not modified");
        assert_ne!(s3, [70, 80], "Shard 3 was not modified");
    }
}
