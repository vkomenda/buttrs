mod gf2p8;

pub use gf2p8::bit_matrix::BitMatrix;
pub use gf2p8::generic::Gf2p8;

pub mod generated {
    // Include the constants generated by build.rs
    include!(concat!(env!("OUT_DIR"), "/twiddle_factors_11d.rs"));
}

/// The Additive FFT Recursive Step
/// This divides the N shards into two N/2 square sub-problems.
pub fn fft_recursive(shards: &mut [&mut [u8]], twiddles: &[BitMatrix]) {
    let n = shards.len();
    if n <= 1 {
        return;
    }

    let half = n / 2;
    let (top, bottom) = shards.split_at_mut(half);

    // Recursive Step (Divide)
    fft_recursive(top, &twiddles[1..]);
    fft_recursive(bottom, &twiddles[1..]);

    // Butterfly Combine (Conquer)
    // In an additive FFT, this stage interacts rows of the top block with the bottom block.
    let mat = twiddles[0];

    for i in 0..half {
        for j in 0..top[i].len() {
            let u = top[i][j];
            let v = bottom[i][j];

            // Standard Additive Butterfly:
            // u' = u + v
            // v' = v * Twiddle + u
            let u_new = u ^ v;
            let v_weighted = mat.apply(v);
            let v_new = v_weighted ^ u; // Note: using 'u' here preserves entropy

            top[i][j] = u_new;
            bottom[i][j] = v_new;
        }
    }
}

pub fn ifft_recursive(shards: &mut [&mut [u8]], twiddles: &[BitMatrix]) {
    let n = shards.len();
    if n <= 1 {
        return;
    }

    let half = n / 2;
    let (top, bottom) = shards.split_at_mut(half);

    ifft_recursive(top, &twiddles[1..]);
    ifft_recursive(bottom, &twiddles[1..]);

    let mat = twiddles[0];
    for i in 0..half {
        for j in 0..top[i].len() {
            let u = top[i][j];
            let v = bottom[i][j];

            // Inverse butterfly logic
            let u_new = u ^ v;
            let v_weighted = mat.apply(u_new);
            top[i][j] = u_new;
            bottom[i][j] = v ^ v_weighted;
        }
    }
}

pub fn reconstruct_in_place<const N: usize, G: Gf2p8>(
    shards: &mut [&mut [u8]], // All N shards, some filled, some not
    is_erased: &[bool; N],    // Which indices are missing
    twiddles: &[BitMatrix],   // precomputed matrices
    basis: &[G],              // Cantor basis
) {
    let erased_indices: Vec<u8> = (0..N as u8).filter(|&i| is_erased[i as usize]).collect();

    // Pre-weighting
    for i in 0..N as u8 {
        if !is_erased[i as usize] {
            let weight = G::eval_erasure_locator_poly(i, &erased_indices, basis);
            let mat = weight.into_bit_matrix();
            for byte in shards[i as usize].iter_mut() {
                *byte = mat.apply(*byte);
            }
        }
    }

    // Forward FFT + Inverse FFT
    // This "mixes" the known weighted values into the erasure slots.
    fft_recursive(shards, twiddles);
    ifft_recursive(shards, twiddles);

    // Post-weighting (correction)
    for i in 0..N as u8 {
        if is_erased[i as usize] {
            // In additive RS, the correction weight is 1 / E'(alpha_i).
            // For simple erasures, we evaluate the derivative polynomial.
            let corr_weight = G::eval_erasure_locator_poly(i, &erased_indices, basis).inv();
            let mat = corr_weight.into_bit_matrix();
            for byte in shards[i as usize].iter_mut() {
                *byte = mat.apply(*byte);
            }
        }
    }
}

pub fn reconstruct_systematic<const N: usize, G: Gf2p8>(
    received: &[(u8, &[u8])],    // received shards with their indices
    workspace: &mut [&mut [u8]], // pre-allocated N shards
    twiddles: &[BitMatrix],      //
    basis: &[G],                 // Cantor basis
) -> bool {
    let shard_len = workspace[0].len();

    // Identify which indices are missing (needed for locator polynomial)
    let mut is_erased = [true; N];
    for &(idx, _) in received {
        is_erased[idx as usize] = false;
    }

    let erased_indices: Vec<u8> = (0..N as u8).filter(|&i| is_erased[i as usize]).collect();

    // Prepare the workspace: map received shards & pre-weight
    // We only touch the indices we actually received.
    for &(idx, data) in received {
        // Copy original to workspace
        workspace[idx as usize].copy_from_slice(data);

        // Apply weight E(alpha_idx)
        let weight = G::eval_erasure_locator_poly(idx, &erased_indices, basis);
        let mat = weight.into_bit_matrix();
        for byte in workspace[idx as usize].iter_mut() {
            *byte = mat.apply(*byte);
        }
    }

    // Zero-fill the gaps in the workspace
    for &idx in &erased_indices {
        workspace[idx as usize].fill(0);
    }

    // Transform: forward FFT followed by Inverse FFT
    fft_recursive(workspace, twiddles);
    ifft_recursive(workspace, twiddles);

    // Integrity check: witness test
    // For a received shard, the workspace now contains (original * E(alpha_w))
    let (witness_idx, witness_original_data) = received[0];
    let weight = G::eval_erasure_locator_poly(witness_idx, &erased_indices, basis).inv();
    let mat = weight.into_bit_matrix();

    for i in 0..shard_len {
        let recovered_byte = mat.apply(workspace[witness_idx as usize][i]);
        if recovered_byte != witness_original_data[i] {
            return false;
        }
    }

    // Post-weight: recover all erased shards
    for &idx in &erased_indices {
        // Apply correction weight 1 / E'(alpha_idx)
        let corr_weight = G::eval_erasure_locator_poly(idx, &erased_indices, basis).inv();

        let mat = corr_weight.into_bit_matrix();
        for byte in workspace[idx as usize].iter_mut() {
            *byte = mat.apply(*byte);
        }
    }

    true
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_recursive_fft_4_shards() {
        // Data: 4 shards of 2 bytes each
        let mut s0 = [10, 20];
        let mut s1 = [30, 40];
        let mut s2 = [50, 60];
        let mut s3 = [70, 80];

        let mut shards: Vec<&mut [u8]> = vec![&mut s0, &mut s1, &mut s2, &mut s3];

        fft_recursive(&mut shards, &generated::TWIDDLE_FACTORS_11D);

        println!("s0: {:?}, s1: {:?}, s2: {:?}, s3: {:?}", s0, s1, s2, s3);

        // Verify that all shards were modified
        assert_ne!(s0, [10, 20], "Shard 0 was not modified");
        assert_ne!(s1, [30, 40], "Shard 1 was not modified");
        assert_ne!(s2, [50, 60], "Shard 2 was not modified");
        assert_ne!(s3, [70, 80], "Shard 3 was not modified");
    }
}
