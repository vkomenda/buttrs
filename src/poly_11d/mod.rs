use crate::gf2p8::{
    CantorBasis, CantorBasis11d, Gf2p8_11d,
    bit_matrix::BitMatrix,
    generic::{CantorBasisLut, Gf2p8Lut},
};

pub mod generated {
    // Include the constants generated by build.rs
    include!(concat!(env!("OUT_DIR"), "/tables_11d.rs"));
}

impl Gf2p8Lut for Gf2p8_11d {
    fn mul_lut(self, other: Self) -> Self {
        todo!()
    }

    fn inv_lut(self) -> Self {
        todo!()
    }
}

#[derive(Copy, Clone, Debug, PartialEq)]
pub struct CantorBasisLut11d {
    twiddle_factors: &'static [BitMatrix],
    cantor_subspace: &'static [u8],
}

impl CantorBasisLut11d {
    pub fn new() -> Self {
        Self {
            twiddle_factors: &generated::TWIDDLE_FACTORS,
            cantor_subspace: &generated::CANTOR_SUBSPACE,
        }
    }
}

impl CantorBasisLut<Gf2p8_11d> for CantorBasisLut11d {
    fn get_subspace_point_lut(&self, i: u8) -> Gf2p8_11d {
        self.cantor_subspace[i as usize].into()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::fft_recursive;

    #[test]
    fn test_recursive_fft_4_shards() {
        // Data: 4 shards of 2 bytes each
        let mut s0 = [10, 20];
        let mut s1 = [30, 40];
        let mut s2 = [50, 60];
        let mut s3 = [70, 80];

        let mut shards: Vec<&mut [u8]> = vec![&mut s0, &mut s1, &mut s2, &mut s3];

        fft_recursive(&mut shards, &generated::TWIDDLE_FACTORS);

        println!("s0: {:?}, s1: {:?}, s2: {:?}, s3: {:?}", s0, s1, s2, s3);

        // Verify that all shards were modified
        assert_ne!(s0, [10, 20], "Shard 0 was not modified");
        assert_ne!(s1, [30, 40], "Shard 1 was not modified");
        assert_ne!(s2, [50, 60], "Shard 2 was not modified");
        assert_ne!(s3, [70, 80], "Shard 3 was not modified");
    }
}
