use crate::gf2p8::{
    Gf2p8, Gf2p8_11d,
    bit_matrix::BitMatrix,
    generic::{CantorBasisLut, Gf2p8Lut, LchBasisLut},
};

pub mod generated {
    // Include the constants generated by build.rs
    include!(concat!(env!("OUT_DIR"), "/tables_11d.rs"));
}

impl Gf2p8Lut for Gf2p8_11d {
    fn mul_lut(self, other: Self) -> Self {
        if self.0 == 0 || other.0 == 0 {
            return 0u8.into();
        }
        let self_log = generated::LOG_TABLE[self.0 as usize] as usize;
        let other_log = generated::LOG_TABLE[other.0 as usize] as usize;
        generated::EXP_TABLE[self_log + other_log].into()
    }

    fn inv_lut(self) -> Self {
        generated::INV_TABLE[u8::from(self) as usize].into()
    }
}

#[derive(Copy, Clone, Debug, PartialEq)]
pub struct BasesLut11d {
    twiddle_factors: &'static [BitMatrix],
    cantor_subspace: &'static [u8],
}

impl BasesLut11d {
    pub fn new() -> Self {
        Self {
            twiddle_factors: &generated::TWIDDLE_FACTORS,
            cantor_subspace: &generated::CANTOR_SUBSPACE,
        }
    }
}

impl CantorBasisLut<Gf2p8_11d> for BasesLut11d {
    fn get_basis_point_lut(&self, i: u8) -> Gf2p8_11d {
        todo!()
    }

    fn get_subspace_point_lut(&self, i: u8) -> Gf2p8_11d {
        self.cantor_subspace[i as usize].into()
    }

    fn eval_subspace_poly_lut(&self, k: u8, x: Gf2p8_11d) -> Gf2p8_11d {
        generated::SUBSPACE_POLY_VALUES[k as usize][x.into_usize()].into()
    }
}

impl LchBasisLut<Gf2p8_11d> for BasesLut11d {}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::{
        encode, fft_recursive,
        gf2p8::{CantorBasis, CantorBasis11d, Gf2p8},
        ifft_recursive, reconstruct_systematic,
    };

    #[test]
    fn mul_lut_correctness() {
        let a: Gf2p8_11d = 0x42.into();
        let b = 0x13.into();
        let expected = a.mul(b);
        let actual = a.mul_lut(b);

        assert_eq!(actual, expected);
    }

    #[test]
    fn bit_matrix_correctness() {
        let a: Gf2p8_11d = 0x42.into();
        let b = 0x13.into();
        let expected = a.mul(b);

        let mat = a.into_bit_matrix();
        let actual = mat.apply(b.into());

        assert_eq!(actual, expected.into());
    }

    #[test]
    fn twiddle_matrix_ranks() {
        let basis = CantorBasis11d::new();
        let twiddles = basis.generate_lch_twiddle_tower::<256>();

        for (i, mat) in twiddles.iter().enumerate() {
            let rank = mat.rank();
            assert_eq!(
                rank, 8,
                "Twiddle matrix at layer {} is singular (Rank {})",
                i, rank
            );
        }
    }
    #[test]
    fn verify_unique_points() {
        let basis = CantorBasis11d::new();
        let twiddles = basis.generate_lch_twiddle_tower::<256>();

        println!("{twiddles:?}");

        let mut shards = vec![vec![0u8; 1]; 256];
        shards[1][0] = 1; // f(x) = x

        let mut refs: Vec<&mut [u8]> = shards.iter_mut().map(|s| s.as_mut_slice()).collect();
        fft_recursive(&mut refs, &twiddles);

        println!("{shards:?}");

        let mut seen = std::collections::HashSet::new();
        for i in 0..256 {
            let val = shards[i][0];
            assert!(
                seen.insert(val),
                "Duplicate point {} found at index {}!",
                val,
                i
            );
        }
    }

    #[test]
    fn recursive_fft_4_shards() {
        // Data: 4 shards of 2 bytes each
        let mut s0 = [10, 20];
        let mut s1 = [30, 40];
        let mut s2 = [50, 60];
        let mut s3 = [70, 80];

        let mut shards: Vec<&mut [u8]> = vec![&mut s0, &mut s1, &mut s2, &mut s3];

        fft_recursive(&mut shards, &generated::TWIDDLE_FACTORS);

        // Verify that all shards were modified
        assert_ne!(s0, [10, 20], "Shard 0 was not modified");
        assert_ne!(s1, [30, 40], "Shard 1 was not modified");
        assert_ne!(s2, [50, 60], "Shard 2 was not modified");
        assert_ne!(s3, [70, 80], "Shard 3 was not modified");
    }

    #[test]
    fn fft_ifft_composition_identity() {
        let basis = BasesLut11d::new();
        let twiddles = &basis.twiddle_factors;

        let mut original = vec![vec![0u8; 1]; 128];
        for i in 0..128 {
            original[i][0] = i as u8;
        }

        let mut work = original.clone();
        let mut refs: Vec<&mut [u8]> = work.iter_mut().map(|s| s.as_mut_slice()).collect();

        // Transform to evaluations
        fft_recursive(&mut refs, twiddles);

        // Transform back to coefficients
        ifft_recursive(&mut refs, twiddles);

        assert_eq!(work, original);
    }

    #[test]
    fn dual_subspace_identity() {
        const N_DATA_SHARDS: usize = 128;
        const SHARD_LEN: usize = 8;
        let basis = BasesLut11d::new();
        let twiddles = &basis.twiddle_factors;
        let bridge_mat = twiddles[0];
        let recursive_twiddles = &twiddles[1..];

        let mut data_shards = vec![vec![0u8; SHARD_LEN]; N_DATA_SHARDS];
        for i in 0..N_DATA_SHARDS {
            for j in 0..SHARD_LEN {
                data_shards[i][j] = (i ^ j) as u8; // Random-ish data
            }
        }

        let mut expected_parity = vec![vec![0u8; SHARD_LEN]; N_DATA_SHARDS];
        {
            let data_refs: Vec<&[u8]> = data_shards.iter().map(|s| s.as_slice()).collect();
            let mut parity_refs: Vec<&mut [u8]> = expected_parity
                .iter_mut()
                .map(|s| s.as_mut_slice())
                .collect();
            encode::<N_DATA_SHARDS, Gf2p8_11d>(&data_refs, &mut parity_refs, twiddles);
        }

        let mut manual_parity = data_shards.clone();
        let mut manual_refs: Vec<&mut [u8]> =
            manual_parity.iter_mut().map(|s| s.as_mut_slice()).collect();
        ifft_recursive(&mut manual_refs, recursive_twiddles);

        for i in 0..N_DATA_SHARDS {
            for j in 0..SHARD_LEN {
                manual_refs[i][j] = bridge_mat.apply(manual_refs[i][j]);
            }
        }

        fft_recursive(&mut manual_refs, recursive_twiddles);

        for i in 0..N_DATA_SHARDS {
            assert_eq!(
                manual_refs[i], expected_parity[i],
                "Bridge identity failed at shard {}. Identity: P = FFT(Bridge(IFFT(D)))",
                i
            );
        }
    }

    /// Helper to create a 64-shard codeword (32 data, 32 parity)
    fn generate_test_codeword(shard_len: usize) -> Vec<Vec<u8>> {
        let basis = BasesLut11d::new();
        let twiddles = &basis.twiddle_factors[2..];

        // Create 32 data shards with distinct patterns
        let mut shards = vec![vec![0u8; shard_len]; 64];
        for i in 0..32 {
            for j in 0..shard_len {
                shards[i][j] = (i ^ j) as u8;
            }
        }

        // Encode to generate shards 32..64 (Parity)
        // Note: Using a temporary slice-of-mut-slices for the encoder
        let mut refs: Vec<&mut [u8]> = shards.iter_mut().map(|s| s.as_mut_slice()).collect();
        let (data_part, parity_part) = refs.split_at_mut(32);

        encode::<32, Gf2p8_11d>(
            &data_part.iter().map(|s| s.as_ref()).collect::<Vec<_>>(),
            parity_part,
            twiddles,
        );

        shards
    }

    #[test]
    fn reconstruct_success_max_erasures() {
        let shard_len = 64;
        let original_codeword = generate_test_codeword(shard_len);
        let basis = BasesLut11d::new();
        let twiddles = &basis.twiddle_factors[2..];

        // Simulate receiving exactly 32 shards (0..16 data and 32..48 parity)
        let mut received = Vec::new();
        for i in 0..16 {
            received.push((i as u8, original_codeword[i].as_slice()));
        }
        for i in 32..48 {
            received.push((i as u8, original_codeword[i].as_slice()));
        }

        // Setup workspace
        let mut workspace_data = vec![vec![0u8; shard_len]; 64];
        let mut workspace: Vec<&mut [u8]> = workspace_data
            .iter_mut()
            .map(|s| s.as_mut_slice())
            .collect();

        // Reconstruct
        let success =
            reconstruct_systematic::<64, Gf2p8_11d>(&received, &mut workspace, twiddles, &basis);

        assert!(success, "Reconstruction should have succeeded");

        // Verify a missing data shard
        assert_eq!(
            workspace[20], original_codeword[20],
            "Data shard 20 mismatch"
        );

        // Verify a missing parity shard
        assert_eq!(
            workspace[50], original_codeword[50],
            "Parity shard 50 mismatch"
        );
    }

    #[test]
    fn reconstruct_no_erasures() {
        let shard_len = 8;
        let original_codeword = generate_test_codeword(shard_len);
        let basis = BasesLut11d::new();
        let twiddles = &basis.twiddle_factors[2..];

        let mut received = Vec::new();
        for i in 0..64 {
            received.push((i as u8, original_codeword[i].as_slice()));
        }

        let mut workspace_data = vec![vec![0u8; shard_len]; 64];
        let mut workspace: Vec<&mut [u8]> = workspace_data
            .iter_mut()
            .map(|s| s.as_mut_slice())
            .collect();

        let success =
            reconstruct_systematic::<64, Gf2p8_11d>(&received, &mut workspace, twiddles, &basis);

        assert!(success);
        for i in 0..64 {
            assert_eq!(workspace[i], original_codeword[i]);
        }
    }

    #[test]
    fn span_eq_span_by_gray_code() {
        let basis = CantorBasis11d::new();
        for i in 0..9 {
            let s1 = basis.span(i);
            let s2 = basis.span_by_gray_code(i);
            assert_eq!(s1, s2, "spans of dimension {i} differ");
        }
    }

    fn unwrap_gfs<'a>(it: impl Iterator<Item = &'a Gf2p8_11d>) -> Vec<u8> {
        it.map(|&x| u8::from(x)).collect()
    }

    #[test]
    fn all_subspace_poly_luts() {
        let basis = CantorBasis11d::new();
        let incremental_luts: Vec<_> = (0..9).map(|k| basis.gen_subspace_poly_lut(k)).collect();
        let all_luts = basis.gen_all_subspace_poly_luts();
        for (k, &lut) in all_luts.iter().enumerate() {
            println!("LUT {k}: {:?}", unwrap_gfs(lut.iter()));
            assert_eq!(lut, incremental_luts[k]);
        }

        println!(
            "Chain of subspaces: {:?}",
            basis
                .chain_of_subspaces()
                .iter()
                .map(|ss| unwrap_gfs(ss.iter()))
                .collect::<Vec<_>>()
        );
    }

    #[test]
    fn subspace_poly_luts_match_over_subspace_chain() {
        let basis = CantorBasis11d::new();
        let all_luts = basis.gen_all_subspace_poly_luts();
        let subspace_chain = basis.chain_of_subspaces();
        for (lut, ss) in all_luts.iter().zip(subspace_chain.iter()) {
            for (x, &p) in lut.iter().enumerate() {
                let gf_x: Gf2p8_11d = (x as u8).into();
                let mut prod: Gf2p8_11d = 1u8.into();
                for &a in ss {
                    prod = prod.mul(gf_x.add(a));
                }
                assert_eq!(p, prod);
            }
        }
    }

    // #[test]
    // fn all_compact_subspace_poly_luts() {
    //     let basis = CantorBasis11d::new();
    //     let print_lut = |k, it| {
    //         println!("{k}-th compact LUT: {:?}", unwrap_gfs(it));
    //     };
    //     let lut0 = basis.gen_compact_subspace_poly_lut::<256>();
    //     let lut1 = basis.gen_compact_subspace_poly_lut::<128>();
    //     let lut2 = basis.gen_compact_subspace_poly_lut::<64>();
    //     let lut3 = basis.gen_compact_subspace_poly_lut::<32>();
    //     let lut4 = basis.gen_compact_subspace_poly_lut::<16>();
    //     let lut5 = basis.gen_compact_subspace_poly_lut::<8>();
    //     let lut6 = basis.gen_compact_subspace_poly_lut::<4>();
    //     let lut7 = basis.gen_compact_subspace_poly_lut::<2>();
    //     let lut8 = basis.gen_compact_subspace_poly_lut::<1>();

    //     print_lut(0, lut0.iter());
    //     print_lut(1, lut1.iter());
    //     print_lut(2, lut2.iter());
    //     print_lut(3, lut3.iter());
    //     print_lut(4, lut4.iter());
    //     print_lut(5, lut5.iter());
    //     print_lut(6, lut6.iter());
    //     print_lut(7, lut7.iter());
    //     print_lut(8, lut8.iter());
    // }

    #[test]
    fn normalization_factors_id() {
        let basis = CantorBasis11d::new();
        let subpoly_luts = basis.gen_all_subspace_poly_luts();
        let norm_factors = basis.gen_normalization_factors(&subpoly_luts, &generated::INV_TABLE);
        assert_eq!(norm_factors, [1u8; 256]);
    }
}
